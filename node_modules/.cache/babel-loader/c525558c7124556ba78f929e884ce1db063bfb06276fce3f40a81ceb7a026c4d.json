{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchCityWeather, fetchCityHourlyForecast } from '../api/weatherApi';\n\n// Types\n\nconst initialState = {\n  cities: [],\n  hourlyForecasts: {},\n  status: 'idle',\n  error: null\n};\n\n// Load cities from localStorage on initialization\nconst savedCities = localStorage.getItem('weatherCities');\nif (savedCities) {\n  try {\n    initialState.cities = JSON.parse(savedCities);\n  } catch (e) {\n    console.error('Failed to parse saved cities from localStorage', e);\n  }\n}\n\n// Async thunks\nexport const fetchWeatherForCity = createAsyncThunk('weather/fetchWeatherForCity', async cityName => {\n  const response = await fetchCityWeather(cityName);\n  return {\n    ...response,\n    lastUpdated: Date.now()\n  };\n});\nexport const updateCityWeather = createAsyncThunk('weather/updateCityWeather', async (cityId, {\n  getState\n}) => {\n  const state = getState();\n  const city = state.weather.cities.find(c => c.id === cityId);\n  if (!city) {\n    throw new Error('City not found');\n  }\n  const response = await fetchCityWeather(city.name);\n  return {\n    ...response,\n    lastUpdated: Date.now()\n  };\n});\nexport const fetchHourlyForecast = createAsyncThunk('weather/fetchHourlyForecast', async (cityId, {\n  getState\n}) => {\n  const state = getState();\n  const city = state.weather.cities.find(c => c.id === cityId);\n  if (!city) {\n    throw new Error('City not found');\n  }\n  const response = await fetchCityHourlyForecast(city.name);\n  return {\n    cityId,\n    list: response.list\n  };\n});\nconst weatherSlice = createSlice({\n  name: 'weather',\n  initialState,\n  reducers: {\n    removeCity: (state, action) => {\n      state.cities = state.cities.filter(city => city.id !== action.payload);\n      delete state.hourlyForecasts[action.payload];\n\n      // Update localStorage\n      localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // fetchWeatherForCity\n    .addCase(fetchWeatherForCity.pending, state => {\n      state.status = 'loading';\n    }).addCase(fetchWeatherForCity.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      // Check if city already exists\n      const existingCityIndex = state.cities.findIndex(city => city.id === action.payload.id);\n      if (existingCityIndex >= 0) {\n        // Update existing city\n        state.cities[existingCityIndex] = action.payload;\n      } else {\n        // Add new city\n        state.cities.push(action.payload);\n      }\n\n      // Update localStorage\n      localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n    }).addCase(fetchWeatherForCity.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message || 'Failed to fetch weather data';\n    })\n\n    // updateCityWeather\n    .addCase(updateCityWeather.pending, state => {\n      state.status = 'loading';\n    }).addCase(updateCityWeather.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      const index = state.cities.findIndex(city => city.id === action.payload.id);\n      if (index !== -1) {\n        state.cities[index] = action.payload;\n        // Update localStorage\n        localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n      }\n    }).addCase(updateCityWeather.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message || 'Failed to update weather data';\n    })\n\n    // fetchHourlyForecast\n    .addCase(fetchHourlyForecast.pending, state => {\n      state.status = 'loading';\n    }).addCase(fetchHourlyForecast.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      state.hourlyForecasts[action.payload.cityId] = action.payload;\n    }).addCase(fetchHourlyForecast.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message || 'Failed to fetch hourly forecast';\n    });\n  }\n});\nexport const {\n  removeCity\n} = weatherSlice.actions;\n\n// Selectors\nexport const selectAllCities = state => state.weather.cities;\nexport const selectCityById = (state, cityId) => state.weather.cities.find(city => city.id === cityId);\nexport const selectHourlyForecastById = (state, cityId) => state.weather.hourlyForecasts[cityId];\nexport const selectWeatherStatus = state => state.weather.status;\nexport const selectWeatherError = state => state.weather.error;\nexport default weatherSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","fetchCityWeather","fetchCityHourlyForecast","initialState","cities","hourlyForecasts","status","error","savedCities","localStorage","getItem","JSON","parse","e","console","fetchWeatherForCity","cityName","response","lastUpdated","Date","now","updateCityWeather","cityId","getState","state","city","weather","find","c","id","Error","name","fetchHourlyForecast","list","weatherSlice","reducers","removeCity","action","filter","payload","setItem","stringify","extraReducers","builder","addCase","pending","fulfilled","existingCityIndex","findIndex","push","rejected","message","index","actions","selectAllCities","selectCityById","selectHourlyForecastById","selectWeatherStatus","selectWeatherError","reducer"],"sources":["/Users/maczone/WebstormProjects/weatherHelper/src/store/weatherSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from './index';\nimport { fetchCityWeather, fetchCityHourlyForecast } from '../api/weatherApi';\n\n// Types\nexport interface WeatherData {\n  id: number;\n  name: string;\n  main: {\n    temp: number;\n    feels_like: number;\n    temp_min: number;\n    temp_max: number;\n    pressure: number;\n    humidity: number;\n  };\n  weather: Array<{\n    id: number;\n    main: string;\n    description: string;\n    icon: string;\n  }>;\n  wind: {\n    speed: number;\n    deg: number;\n  };\n  sys: {\n    country: string;\n    sunrise: number;\n    sunset: number;\n  };\n  dt: number; // Time of data calculation\n  lastUpdated: number; // Timestamp when we last updated this data\n}\n\nexport interface HourlyForecast {\n  cityId: number;\n  list: Array<{\n    dt: number;\n    main: {\n      temp: number;\n      feels_like: number;\n      temp_min: number;\n      temp_max: number;\n      pressure: number;\n      humidity: number;\n    };\n    weather: Array<{\n      id: number;\n      main: string;\n      description: string;\n      icon: string;\n    }>;\n    wind: {\n      speed: number;\n      deg: number;\n    };\n  }>;\n}\n\ninterface WeatherState {\n  cities: WeatherData[];\n  hourlyForecasts: Record<number, HourlyForecast>;\n  status: 'idle' | 'loading' | 'succeeded' | 'failed';\n  error: string | null;\n}\n\nconst initialState: WeatherState = {\n  cities: [],\n  hourlyForecasts: {},\n  status: 'idle',\n  error: null,\n};\n\n// Load cities from localStorage on initialization\nconst savedCities = localStorage.getItem('weatherCities');\nif (savedCities) {\n  try {\n    initialState.cities = JSON.parse(savedCities);\n  } catch (e) {\n    console.error('Failed to parse saved cities from localStorage', e);\n  }\n}\n\n// Async thunks\nexport const fetchWeatherForCity = createAsyncThunk(\n  'weather/fetchWeatherForCity',\n  async (cityName: string) => {\n    const response = await fetchCityWeather(cityName);\n    return {\n      ...response,\n      lastUpdated: Date.now(),\n    };\n  }\n);\n\nexport const updateCityWeather = createAsyncThunk(\n  'weather/updateCityWeather',\n  async (cityId: number, { getState }) => {\n    const state = getState() as RootState;\n    const city = state.weather.cities.find(c => c.id === cityId);\n    \n    if (!city) {\n      throw new Error('City not found');\n    }\n    \n    const response = await fetchCityWeather(city.name);\n    return {\n      ...response,\n      lastUpdated: Date.now(),\n    };\n  }\n);\n\nexport const fetchHourlyForecast = createAsyncThunk(\n  'weather/fetchHourlyForecast',\n  async (cityId: number, { getState }) => {\n    const state = getState() as RootState;\n    const city = state.weather.cities.find(c => c.id === cityId);\n    \n    if (!city) {\n      throw new Error('City not found');\n    }\n    \n    const response = await fetchCityHourlyForecast(city.name);\n    return {\n      cityId,\n      list: response.list,\n    };\n  }\n);\n\nconst weatherSlice = createSlice({\n  name: 'weather',\n  initialState,\n  reducers: {\n    removeCity: (state, action: PayloadAction<number>) => {\n      state.cities = state.cities.filter(city => city.id !== action.payload);\n      delete state.hourlyForecasts[action.payload];\n      \n      // Update localStorage\n      localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // fetchWeatherForCity\n      .addCase(fetchWeatherForCity.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchWeatherForCity.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        // Check if city already exists\n        const existingCityIndex = state.cities.findIndex(\n          city => city.id === action.payload.id\n        );\n        \n        if (existingCityIndex >= 0) {\n          // Update existing city\n          state.cities[existingCityIndex] = action.payload;\n        } else {\n          // Add new city\n          state.cities.push(action.payload);\n        }\n        \n        // Update localStorage\n        localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n      })\n      .addCase(fetchWeatherForCity.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message || 'Failed to fetch weather data';\n      })\n      \n      // updateCityWeather\n      .addCase(updateCityWeather.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(updateCityWeather.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        const index = state.cities.findIndex(city => city.id === action.payload.id);\n        if (index !== -1) {\n          state.cities[index] = action.payload;\n          // Update localStorage\n          localStorage.setItem('weatherCities', JSON.stringify(state.cities));\n        }\n      })\n      .addCase(updateCityWeather.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message || 'Failed to update weather data';\n      })\n      \n      // fetchHourlyForecast\n      .addCase(fetchHourlyForecast.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchHourlyForecast.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.hourlyForecasts[action.payload.cityId] = action.payload;\n      })\n      .addCase(fetchHourlyForecast.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message || 'Failed to fetch hourly forecast';\n      });\n  },\n});\n\nexport const { removeCity } = weatherSlice.actions;\n\n// Selectors\nexport const selectAllCities = (state: RootState) => state.weather.cities;\nexport const selectCityById = (state: RootState, cityId: number) => \n  state.weather.cities.find(city => city.id === cityId);\nexport const selectHourlyForecastById = (state: RootState, cityId: number) => \n  state.weather.hourlyForecasts[cityId];\nexport const selectWeatherStatus = (state: RootState) => state.weather.status;\nexport const selectWeatherError = (state: RootState) => state.weather.error;\n\nexport default weatherSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}